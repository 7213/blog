# 词法和语法
当在chrome的控制台输入：` var a = '1+1' `，会紧跟着一个undefined，这个undefined又代表什么呢？  
  
要回答这个问题，需要从JS引擎执行JS源码说起，实际上现代的JS引擎基本会运用JIT来优化JS脚本的执行速度，所以JS在某种程度也可以看作是一种编译语言。
   
在经典的编译原理中，会将编译器分为前端和后端。
   
前端：仅与编译的源代码相关

- 词法分析(Token)
- 语法分析(Parser)
- 语义分析

后端：和目标语言相关

- 字节码
- 目标代码

抽离两部分是为了方便一种源代码在不同目标语言上的实现，在编译器前端部分已经完成此种语言的语法、语义的定义，所以我们要回答开头的那个问题只需关注JS编译器的前端即可。


本文后面的部分，我将尝试（挖坑）实现一个简单的JS编译器前端来解析、理解` var a = '1+1' `，并回答undefined代表什么
## 词法分析
词法分析将源码按我们定义的编程语言规则进行分词，它输出tokens作为语法分析的输入

`source code --> tokens --> parser --> ast`

如何从源代码识别出一个个"词法单元"呢？只要按照*词法单元的定义*尽可能多的消费掉源码即可识别出一个词法单元。
下面来看看这个简单JS引擎的词法定义
![tokens](../resource/token.png)

这里举个例子说明，如果有这样一段源码

```javascript

const name = "7213";
if (name === '7213') {
    console.log(1);
}
```

忽略掉源码中的空格然后从源码字符流中逐字符分析，根据上图按"英文字母那一框"的定义尽可能的消费掉源码，即可获得第一个*词法单元* `const`。
然后从const后的下一个字符开始，递归消费掉所有源码，即可获得tokens。


我们可以根据词法定义构建有穷状态机来解出tokens，但是有穷自动机需要大量的回溯，所以我们既不自己构建有穷状态机也不使用正则，而是通过根据词法定义简单的分析字符串流的方式来拆解出tokens


## 词法作用域

## 构建AST

## JS是如何理解this的

## 语义分析

## 参考
Douglas Crockford关于TDOP一个讲解和JS实现d44:https://github.com/douglascrockford/TDOP
