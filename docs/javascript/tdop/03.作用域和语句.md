本文是《前端学编译原理》的结束篇，所以回到《开篇》中这个问题：
```javascript
(function exprFn(){}) // ƒ exprFn(){}
{function stmtFn(){}} // undefined
```
当我们在chrome输入上面两行，chrome第一行输出 `ƒ exprFn(){}` ，第二行输出 `undefined` ，JS引擎是如何理解上面两行并作出不同输出的呢？   
在《第二篇》中介绍了如何使用TDOP技术生成AST，在上面的例子中第一行遇到"("symbol会解析、前进至(advance)词法至")"的地方并识别为**JS表达式**。第二行symbol"{"将会会解析、前进至"}"识别为**语句**。
在JS规范中中"表达式"可以用在任何表示"值"的地方，"JS表达式"是有返回值的，而"JS语句"则反之。

```javacript
typeof  (function exprFn(){}); // function
typeof  {function exprFn(){}}; // Uncaught SyntaxError: Unexpected identifier
```

在Douglas Crockford的原文中parse输入的源码必须是JS语句开始，解析过程如下
- 首先将源码解析为tokens
- 创建顶层作用域
- 解析"JS语句"(statements)开始构建AST
- 解析值symbol`"(end)"`结束
- 推出顶层作用域
- 返回AST(s)
```javascript
function parse(source) {
    tokens = source.tokens("=<>!+-*&|/%^", "=<>&|");
    token_nr = 0;
    scope = null;
    new_scope();
    advance();
    var s = statements();
    advance("(end)");
    scope.pop();
    return s;
};
```

## 作用域
作用域是"写变量"和"读变量"时的一片区域，它用来控制存储新变量和控制变量的可见性。作用域是可以嵌套的。
每进入一个定义的作用域块（ES5中进入一个函数）就创建一个作用域对象并且将当前作用域作为自己的parent，从而将作用域生成一条链，scope指向当前进入的作用域。
当遇到一个变量时如果语法是定义就在当前作用域define来定义变量，如果是获取值，就使用find来查找此变量。当离开作用域块就pop，将当前作用域指回parent
它的原型定义如下：

```javascript
var original_scope = {
    define: function (n) {
        var t = this.def[n.value];
        if (typeof t === "object") {
            n.error((t.reserved)
                ? "Already reserved."
                : "Already defined.");
        }
        this.def[n.value] = n;
        n.reserved = false;
        n.nud = itself;
        n.led = null;
        n.std = null;
        n.lbp = 0;
        n.scope = scope;
        return n;
    },
    find: function (n) {
        var e = this;
        var o;
        while (true) {
            o = e.def[n];
            if (o && typeof o !== "function") {
                return e.def[n];
            }
            e = e.parent;
            if (!e) {
                o = symbol_table[n];
                return (o && typeof o !== "function")
                    ? o
                    : symbol_table["(name)"];
            }
        }
    },
    pop: function () {
        scope = this.parent;
    },
    reserve: function (n) {
        if (n.arity !== "name" || n.reserved) {
            return;
        }
        var t = this.def[n.value];
        if (t) {
            if (t.reserved) {
                return;
            }
            if (t.arity === "name") {
                n.error("Already defined.");
            }
        }
        this.def[n.value] = n;
        n.reserved = true;
    }
};
```

- define

## 语句

### 解析代码块

### 解析function

### 解析while


## 表达式
在《第二篇》提及symbol的三要素：
- nud
- led
- bp

nud关注右值用于前缀表达式、led关注左值用在中缀和后缀表达式。


### 前缀运算符


### 中缀运算符

### 后缀运算符



